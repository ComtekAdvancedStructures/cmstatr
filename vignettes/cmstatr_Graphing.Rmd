---
title: "Plotting Composite Material Data"
author: "Vignette Author"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette demonstrates how to create some of the graphs commonly used
when analyzing composite material data. Here, we rely on the
[ggplot2](https://ggplot2.tidyverse.org/) package for graphing.

We'll need to load a few packages in order to proceed.

```{r message=FALSE}
library(tidyverse)
library(cmstatr)
library(stats)
library(fitdistrplus)
library(ggplot2)
library(ggsci)
```

Throughout this vignette, we'll use one of the example data sets that
comes with `cmstatr` and we'll focus on the warp-tension data as an
example. We'll load the example data in a variable as follows. By default
the condition will be in an arbitrary order, but throughout the visualization,
we'll want the conditions shown in a particular order (from coldest and dryest
to hottest and wettest). We can define the order of the conditions using
the `ordered` function.

```{r}
dat <- carbon.fabric.2 %>%
  filter(test == "WT") %>%
  mutate(condition = ordered(condition, c("CTD", "RTD", "ETW", "ETW2")))

dat
```

We'll then calculate the B-Basis value using pooling by standard deviation.
This dataset happens to fail some of the diagnostic tests, but for the
purpose of this example, we'll ignore those failures using the
`override` argument.

```{r}
b_basis <- dat %>%
  basis_pooled_cv(strength, condition, batch,
                  override = c("between_group_variability",
                               "normalized_variance_equal"))
```

The object returned from `basis_pooled_cv` contains a number of values.
One value is a `data.frame` containing the groups (ie. conditions)
and the corresponding basis values. This looks like the following. We'll
use this in the visualizations.

```{r}
b_basis$basis
```

# Batch Plots
Batch plots are used to identify differences between batches.
Simple batch plots can be created using boxplots and adding
horizontal lines for the basis values as follows. Note that
the heavy line in the box of the boxplot is the *median*, not
the mean. The two hinges correspond with the first and third
quantiles and the whiskers extend to the most extreme data point,
or 1.5 times the inner quantile range.

```{r}
dat %>%
  ggplot(aes(x = batch, y = strength)) +
  geom_boxplot() +
  geom_jitter(width = 0.25) +
  geom_hline(aes(yintercept = value),
             data = b_basis$basis %>% rename(condition = group), color = "blue") +
  facet_grid(. ~ condition) +
  theme_bw() +
  ggtitle("Batch Plot") +
  theme(plot.title = element_text(hjust = 0.5)) 
```

# Quantile Plots
A quantile plot provides a graphical summary of sample values. 
This plot displays the sample values and the percentage. A quantile 
plot can  be used to examine the symmetry and tail sizes of the 
underlying distribution. Sharp rises may indicate the presence
of outliers. 

```{r}
dat %>%
  filter(test == "WT") %>%
  ggplot(aes(x = strength, color = condition)) +
  stat_ecdf(geom = "point") +
  coord_flip() +
  theme_bw() +
  ggtitle("Quantile Plot") +
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_color_npg()
```

# Normal Plots
NOTE: This one is a bit more complicated. It will be addressed at a later time.


# Normal Score Plots
The normal scores plot calculates the normal score and plots it against the normal score. 
Normal plots are usful to investigate distributions of data. A sample from a normal distribution 
will ressemble a straight line plot. 

```{r}
dat %>%
  group_by(condition) %>%
  mutate(norm.score = scale(strength)) %>%
  ggplot(aes(x = norm.score, y = strength, colour = condition)) +
  geom_point() +
  ggtitle("Normal Scores Plot") +
  theme(plot.title = element_text(hjust = 0.5)) + 
  scale_color_npg()
```

# Q-Q Plots

A Q-Q plot sets two sets of quanitles against one another. 
IF both quantiles come from the same distribution, the line of points
formed should be rather straight. A 45 degree reference line is also
plotted. If the data sets being plotted are from the same distribution, 
the points should fall roughly along the reference line. 
```{r}
dat %>%
  ggplot(aes(sample = dat$strength, colour = condition)) +
  geom_qq() +
  geom_qq_line() +
  ggtitle("Q-Q Plot") +
  theme(plot.title = element_text(hjust = 0.5))
```

# Property Plots

Property plots allow for a variety of properties for a group to be 
compared to other preoperties within the same group, as well as to 
other group properties. The properties included in this plot are A-Basis, 
B-Basis, Pooled A and B-Basis, Pooled modified cv A and B-Basis, Mean,
Max, and Min for each group.

First, the distribution of each group must be determined. Once the 
distirbution has been determined, the proper basis calculation based 
on that distribution should be filled in below. For example, if the
distribution for the CTD group is lognormal, basis_normal should be 
changed to basis_lognormal (only for that condition).

```{r}
basis_fcn <- tribble(
  ~condition, ~fcn,
  "CTD", "basis_normal",
  "RTD", "basis_normal",
  "ETW", "basis_hk_ext",
  "ETW2", "basis_normal"
)
```
This section calculates the single point A and B basis, as well as the mean, max, and min. 
```{r}
single.point.results <- dat %>%
  group_by(condition) %>%
  nest() %>%
  inner_join(basis_fcn, by = "condition") %>%
  mutate(b.basis = map(data, ~do.call(fcn, list(.x, x = .x$strength, batch = .x$batch, override = "between_batch_variability"))),
         a.basis = map(data, ~do.call(fcn, list(.x, x = .x$strength, batch = .x$batch, override = "between_batch_variability", p = 0.99))),
         tidied.bbasis = map(b.basis, glance),
         tidied.abasis = map(a.basis, glance),
         min = map(data, ~min(.x$strength)), 
         max = map(data, ~max(.x$strength)), 
         mean = map(data, ~mean(.x$strength))) %>%
  unnest(cols = c(tidied.bbasis)) %>%
  dplyr::select(-c(conf, n, modcv, distribution, p, b.basis, r, a.basis)) %>%
  rename(b.basis = basis) %>%
  unnest(tidied.abasis, mean, max, min) %>% 
  rename(a.basis = basis) %>%
  dplyr::select(c(a.basis, b.basis, mean, max, min))
```
This section calculates the pooled A and B basis. 
```{r}
pooled.b.results <- dat %>%
  basis_pooled_cv(strength, condition, batch, override = c("between_group_variability", "normalized_variance_equal")) %>%
  glance() %>%
  as.data.frame() %>%
  dplyr::select(c(basis)) 

pooled.a.results <- dat %>%
  basis_pooled_cv(strength, condition, batch, override = c("between_group_variability", "normalized_variance_equal"), p = 0.99) %>%
  glance() %>%
  as.data.frame() %>%
  dplyr::select(c(basis))

pooled.a.results <- pooled.a.results$basis %>%
  rename(condition = group, a.basis.grouped = value)

pooled.b.results <- pooled.b.results$basis %>%
  rename(condition = group, b.basis.grouped = value)

pooled.results <- pooled.a.results %>%
  inner_join(pooled.b.results, by = "condition")
 
```
This section calclates the A and B basis using the "Pooled Modified CV" method. 
```{r}
pooled.b.results.modcv <- carbon.fabric.2 %>%
  filter(test == "WT") %>%
  basis_pooled_cv(strength, condition, batch, override = c("between_group_variability", "normalized_variance_equal"), modcv = TRUE) %>%
  glance() %>%
  as.data.frame() %>%
  dplyr::select(c(basis)) 

pooled.a.results.modcv <- carbon.fabric.2 %>%
  filter(test == "WT") %>%
  basis_pooled_cv(strength, condition, batch, override = c("between_group_variability", "normalized_variance_equal"), p = 0.99, modcv = TRUE) %>%
  glance() %>%
  as.data.frame() %>%
  dplyr::select(c(basis))

pooled.a.results.modcv <- pooled.a.results.modcv$basis %>%
  rename(condition = group, a.basis.grouped.modcv = value)

pooled.b.results.modcv <- pooled.b.results.modcv$basis %>%
  rename(condition = group, b.basis.grouped.modcv = value)

pooled.results.modcv <- pooled.a.results.modcv %>%
  inner_join(pooled.b.results.modcv, by = "condition") %>%
  inner_join(pooled.results, by = "condition")
```

```{r}
property_plot_results <- single.point.results %>%
  inner_join(pooled.results.modcv, by = "condition")
```
This section plots the properties for all conditions. 
```{r}
property_values <- colnames(property_plot_results)[-1]
property_plot_results %>%
  gather("test", "value", property_values) %>%
  ggplot(aes(x = condition, y = value, color = test)) +
  geom_point(size = 3) +
  ggtitle("Property Graph") +
  theme(plot.title = element_text(hjust = 0.5))+ 
  scale_color_jco()
```




