% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/norm.R
\name{transform_mod_cv}
\alias{transform_mod_cv}
\alias{transform_mod_cv_2}
\title{Transforms data according to the modified CV rule}
\usage{
transform_mod_cv_2(x, condition, batch)

transform_mod_cv(x, group = NULL)
}
\arguments{
\item{x}{a vector of data to transform}

\item{condition}{a vector indicating the condition to which each
observation belongs}

\item{batch}{a vector indicating the batch to which each observation
belongs}

\item{group}{a vector indicating the group to which each observation in
\code{x} belongs. If this is NULL, the data will be treated as
unstructured (without grouping)}
}
\value{
A vector of transformed data
}
\description{
Two versions of this transformation are implemented. The first version,
\code{transform_mod_cv()}, transforms the data in a single group (with
no other structure) according to the modified CV rules.

The second
version, \code{transform_mod_cv_2()}, transforms data that is structured
according to both condition and batch.
}
\details{
\code{transform_mod_cv()} takes a vector
containing the observations and a vector containing the groups that
each observation belongs to and transforms the data. The modified CV
is computed independently within each group and each observation is
transformed according to:

\deqn{\frac{S_i^*}{S_i} (x_i - \bar{x_i}) + \bar{x_i}}{
  Si*/Si (xi-x_bar_i) + x_bar_i
}

Where Si* is the modified standard deviation (mod CV times mean) for
the group; Si is the standard deviation for the group, x_bar_i is
the group mean and xi is the observation.

\code{transform_mod_cv_2()} takes a vector containing the observations
plus a vector containing the corresponding conditions and a vector
containing the batches. This function first calculates the modified
CV value from the data from each condition (independently). Then,
within each condition, the transformation
\code{transform_mod_cv(x, batches)}
is applied to produce the transformed data \eqn{x'}.
This transformed data is further transformed using the following
equation.

\deqn{x'' = C (x'_i - x_bar_i) + x_bar_i}{
  x\prime\prime = C \left(x_i\prime - \bar{x_i}\right) + \bar{x_i}
}

Where:

\deqn{C = sqrt(SSE* / SSE')}{
  C = \sqrt\left(\frac{SSE^{*}}{SSE^{\prime}}\right)
}

\deqn{SSE\* = (n-1) (CV\* x_bar)^2 - sum(n_i(x_bar_i-x_bar)^2)}{
  SSE^{\*} = \left(n-1\right)\left(CV^{\*} \bar{x}\right)^2 -
  \sum\left[n_i \left(\bar{x_i}-\bar{x}\right)^2\right]
}

\deqn{SSE' = sum(x'_i - x_bar_i)^2}{
  SSE\prime = \sum\left(x_i\prime - \bar{x_i}\right)^2
}
}
\examples{
# Transform data according to the modified CV transformation
# and report the original and modified CV for each condition

library(tidyverse)
carbon.fabric \%>\%
  filter(test == "FT") \%>\%
  mutate(trans_strength = transform_mod_cv(strength, condition)) \%>\%
  group_by(condition) \%>\%
  summarize(cv = sd(strength) / mean(strength),
            mod_cv = sd(trans_strength) / mean(trans_strength))

## # A tibble: 3 x 3
##   condition     cv mod_cv
##   <chr>      <dbl>  <dbl>
## 1 CTD       0.0423 0.0612
## 2 ETW       0.0369 0.0600
## 3 RTD       0.0621 0.0711

}
\seealso{
\code{\link{calc_cv_star}}
}
