% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/norm.R
\name{transform_mod_cv}
\alias{transform_mod_cv}
\alias{transform_mod_cv_ad}
\title{Transforms data according to the modified CV rule}
\usage{
transform_mod_cv_ad(x, condition, batch)

transform_mod_cv(x)
}
\arguments{
\item{x}{a vector of data to transform}

\item{condition}{a vector indicating the condition to which each
observation belongs}

\item{batch}{a vector indicating the batch to which each observation
belongs}
}
\value{
A vector of transformed data
}
\description{
Two versions of this transformation are implemented. The first version,
\code{transform_mod_cv()}, transforms the data in a single group (with
no other structure) according to the modified CV rules.

The second
version, \code{transform_mod_cv_ad()}, transforms data that is structured
according to both condition and batch, as is commonly done for
the Anderson--Darling k-Sample and Anderson-Darling tests when pooling
across environments.
}
\details{
\code{transform_mod_cv()} takes a vector
containing the observations and a vector containing the groups that
each observation belongs to and transforms the data. The modified CV
is computed independently within each group and each observation is
transformed according to:

\deqn{\frac{S_i^*}{S_i} (x_i - \bar{x_i}) + \bar{x_i}}{
  Si*/Si (xi-x_bar_i) + x_bar_i
}

Where Si* is the modified standard deviation (mod CV times mean) for
the group; Si is the standard deviation for the group, x_bar_i is
the group mean and xi is the observation.

\code{transform_mod_cv_ad()} takes a vector containing the observations
plus a vector containing the corresponding conditions and a vector
containing the batches. This function first calculates the modified
CV value from the data from each condition (independently). Then,
within each condition, the transformation
\code{transform_mod_cv(x, batches)}
is applied to produce the transformed data \eqn{x'}.
This transformed data is further transformed using the following
equation.

\deqn{x'' = C (x'_i - \bar{x_i}) + \bar{x_i}}{
  x'' = C (x'_i - x_bar_i) + x_bar_i}

Where:

\deqn{C = \sqrt{\frac{SSE^*}{SSE'}}}{C = sqrt(SSE* / SSE')}

\deqn{SSE^* = (n-1) (CV^* \bar{x})^2 - \sum(n_i(\bar{x_i}-\bar{x})^2)}{
  SSE* = (n-1) (CV* x_bar)^2 - sum(n_i(x_bar_i-x_bar)^2)}

\deqn{SSE' = \sum(x'_i - \bar{x_i})^2}{SSE' = sum(x'_i - x_bar_i)^2}
}
\examples{
# Transform data according to the modified CV transformation
# and report the original and modified CV for each condition

library(dplyr)
carbon.fabric \%>\%
  filter(test == "FT") \%>\%
  group_by(condition) \%>\%
  mutate(trans_strength = transform_mod_cv(strength)) \%>\%
  summarize(cv = sd(strength) / mean(strength),
            mod_cv = sd(trans_strength) / mean(trans_strength))

## # A tibble: 3 x 3
##   condition     cv mod_cv
##   <chr>      <dbl>  <dbl>
## 1 CTD       0.0423 0.0612
## 2 ETW       0.0369 0.0600
## 3 RTD       0.0621 0.0711

}
\seealso{
\code{\link{calc_cv_star}}
}
